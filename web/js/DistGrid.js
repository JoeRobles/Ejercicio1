var DistGrid = {
    /**
     * Alleles recorded for that Gel image
     * @type Array
     */
    allelesRecorded: [],
    /**
     * Previous formed matrix
     * @type Array|@exp;newRow@call;concat
     */
    basematrix: [],
    /**
     * Beziers created
     * @type Array
     */
    beziers: [],
    /**
     * Canvas object
     * @type DOM element
     */
    canvas: '',
    /**
     * Current circle
     * @type Array
     */
    circle: [],
    /**
     * Columns drawn
     * @type Array|@exp;newArray@call;concat|@exp;newArray@call;concat
     */
    columns: [],
    /**
     * Current mouse coordenates on canvas
     * @type Array
     */
    coo: [],
    /**
     * Last couple of coordenates
     * @type Array
     */
    couple: [],
    /**
     * Canvas context
     * @type Object
     */
    ctx: '',
    /**
     * Dots clicked
     * @type Array|@exp;newArray@call;concat
     */
    dots: [],
    /**
     * Canvas height
     * @type Integer
     */
    height: 0,
    /**
     * Final Matrix arrange
     * @type Array|newRow
     */
    matrix: [],
    /**
     * Mongo Id of current Gel Image
     * @type String
     */
    mongoId: '',
    /**
     * Actual mouse position on canvas
     * @type Array
     */
    pos: '',
    /**
     * Canvas rectangle
     * @type Object|Generated by getBoundingClientRect javascript method
     */
    rect: '',
    /**
     * Split in
     * @type Integer
     */
    split: 0,
    /**
     * Current step
     * @type Integer
     */
    step: 0,
    /**
     * 
     * @type Object
     */
    styles: {
        /**
         * Color of lines
         * @type String
         */
        line_color: '#470d5f',
        /**
         * Color of dots
         * @type String
         */
        dot_color: 'rgba(0,0,255,1)',
        circle_color: 'rgba(131,221,235,0.3)',
        circle_radius: 8,
        curve: {width: 1, color: "rgba(94,0,0,1)"},
        cpline: {width: 1, color: "rgba(150,150,150,1)"},
        point: {
            radius: 3, 
            width: 2, 
            color: "#f00", 
            fill: "rgba(0,163,8,0.5)", 
            arc1: 0, 
            arc2: 2 * Math.PI
        }
    },
    /**
     * Canvas width
     * @type Integer
     */
    width: 0,
    point: {
        p1: {x: 100, y: 250},
        p2: {x: 400, y: 250}
    },
    drag: null,
    /**
     * 
     * @type String|@exp;DistGrid@call;MousePos|object|@exp;DistGrid@call;MousePos|object
     */
    dPoint: '',
                
                
    /**
     * Inits created canvas
     * 
     * @param {object} ctx
     * @param {object} rect
     * @param {object} canvas
     * @param {integer} height
     * @param {integer} width
     */
    init: function(ctx, rect, canvas, height, width) {
        DistGrid.ctx = ctx;
        DistGrid.rect = rect;
        DistGrid.canvas = canvas;
        DistGrid.height = height;
        DistGrid.width = width;
        DistGrid.point.cp1 = {x: 150, y: 100};
        DistGrid.point.cp2 = {x: 350, y: 100};

        // line style defaults
        DistGrid.ctx.lineCap = "round";
        DistGrid.ctx.lineJoin = "round";
//        var mongo = MongoDBGelImage.mongoGetAll();
        var beziers = MongoDBGelImage.mongoGetBeziers();
        if (beziers !== null) {
            DistGrid.beziers = beziers;
        }
        var columns = MongoDBGelImage.mongoGetColumns();
        if (columns !== null) {
            DistGrid.columns = columns;
        }
        var step = MongoDBGelImage.mongoGetStep();
        if (step !== null) {
            DistGrid.step = step;
        }
        var dots = MongoDBGelImage.mongoGetDots();
        if (dots !== null) {
            DistGrid.dots = dots;
        }
        var matrix = MongoDBGelImage.mongoGetMatrix();
        if (matrix !== null) {
            DistGrid.matrix = matrix;
        }
        setTimeout(function(){
            if (DistGrid.step === 0) {//Vertical lines 
                DistGrid.setVerticalLines();
            } else if (DistGrid.step === 1) {//New bezier
                DistGrid.newBezier();
            } else if (DistGrid.step === 3) {//Set dots
                DistGrid.setDots();
            }
            DistGrid.redrawAll();
        }, 100);
    },
    /**
     * Adds a couple of coordenates to be drawn as a line
     * 
     * @param {type} coordenates
     */
    addCouple: function(coordenates) {
        if (DistGrid.couple === '') {
            DistGrid.couple = coordenates;
        } else if (DistGrid.couple.length === 2) {
            DistGrid.drawLine(DistGrid.couple, coordenates);
            DistGrid.couple = [];
        }
    },
    /**
     * Finds mouse position on canvas
     * 
     * @param {object} obj
     * @returns {Array}
     */
    findPos: function(obj) {
        var curleft = 0, curtop = 0;
        if (obj.offsetParent) {
            do {
                curleft += obj.offsetLeft;
                curtop += obj.offsetTop;
            } while (obj === obj.offsetParent);
            return {x: curleft, y: curtop};
        }
        return undefined;
    },
    /**
     * When dragging ended
     * 
     * @param {object} e
     */
    DragEnd: function(e) {
        DistGrid.drag = null;
        DistGrid.canvas.style.cursor = "default";
        DistGrid.DrawCanvas();
    },
    /**
     * When dragging
     * 
     * @param {object} e
     */
    Dragging: function(e) {
        if (DistGrid.drag) {
            e = DistGrid.MousePos(e);
            DistGrid.point[DistGrid.drag].x += e.x - DistGrid.dPoint.x;
            DistGrid.point[DistGrid.drag].y += e.y - DistGrid.dPoint.y;
            DistGrid.dPoint = e;
            DistGrid.DrawCanvas();
        }
    },
    /**
     * When start dragging
     * 
     * @param {object} e
     */
    DragStart: function(e) {
        if (DistGrid.step === 1) {
            e = DistGrid.MousePos(e);
            var dx, dy;
            for (var p in DistGrid.point) {
                dx = DistGrid.point[p].x - e.x;
                dy = DistGrid.point[p].y - e.y;
                if ((dx * dx) + (dy * dy) < DistGrid.styles.point.radius * DistGrid.styles.point.radius) {
                    DistGrid.drag = p;
                    DistGrid.dPoint = e;
                    DistGrid.canvas.style.cursor = "move";
                    return;
                }
            }
        }
    },
    /**
     * Draws bezier cubic curve
     * 
     * @param {integer} p0x
     * @param {integer} p0y
     * @param {integer} p1x
     * @param {integer} p1y
     * @param {integer} p2x
     * @param {integer} p2y
     * @param {integer} p3x
     * @param {integer} p3y
     */
    drawBezier: function(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
        DistGrid.ctx.lineWidth = DistGrid.styles.curve.width;
        DistGrid.ctx.strokeStyle = DistGrid.styles.curve.color;
        DistGrid.ctx.beginPath();
        DistGrid.ctx.moveTo(p0x, p0y);
        DistGrid.ctx.bezierCurveTo(p1x, p1y, p2x, p2y, p3x, p3y);
        DistGrid.ctx.stroke();
    },
    /**
     * Draws canvas
     */
    DrawCanvas: function() {
        DistGrid.redrawAll();
        // control lines
        DistGrid.ctx.lineWidth = DistGrid.styles.cpline.width;
        DistGrid.ctx.strokeStyle = DistGrid.styles.cpline.color;
        DistGrid.ctx.beginPath();
        DistGrid.ctx.moveTo(DistGrid.point.p1.x, DistGrid.point.p1.y);
        DistGrid.ctx.lineTo(DistGrid.point.cp1.x, DistGrid.point.cp1.y);
        if (DistGrid.point.cp2) {
            DistGrid.ctx.moveTo(DistGrid.point.p2.x, DistGrid.point.p2.y);
            DistGrid.ctx.lineTo(DistGrid.point.cp2.x, DistGrid.point.cp2.y);
        } else {
            DistGrid.ctx.lineTo(DistGrid.point.p2.x, DistGrid.point.p2.y);
        }
        DistGrid.ctx.stroke();
        // curve
        DistGrid.ctx.lineWidth = DistGrid.styles.curve.width;
        DistGrid.ctx.strokeStyle = DistGrid.styles.curve.color;
        DistGrid.ctx.beginPath();
        DistGrid.ctx.moveTo(DistGrid.point.p1.x, DistGrid.point.p1.y);
        if (DistGrid.point.cp2) {
            DistGrid.ctx.bezierCurveTo(
                DistGrid.point.cp1.x,
                DistGrid.point.cp1.y,
                DistGrid.point.cp2.x,
                DistGrid.point.cp2.y,
                DistGrid.point.p2.x,
                DistGrid.point.p2.y
            );
        } else {
            DistGrid.ctx.quadraticCurveTo(
                DistGrid.point.cp1.x,
                DistGrid.point.cp1.y,
                DistGrid.point.p2.x,
                DistGrid.point.p2.y
            );
        }
        DistGrid.ctx.stroke();
        // control points
        for (var p in DistGrid.point) {
            DistGrid.ctx.lineWidth = DistGrid.styles.point.width;
            DistGrid.ctx.strokeStyle = DistGrid.styles.point.color;
            DistGrid.ctx.fillStyle = DistGrid.styles.point.fill;
            DistGrid.ctx.beginPath();
            DistGrid.ctx.arc(
                DistGrid.point[p].x,
                DistGrid.point[p].y,
                DistGrid.styles.point.radius,
                DistGrid.styles.point.arc1,
                DistGrid.styles.point.arc2,
                true
            );
            DistGrid.ctx.fill();
            DistGrid.ctx.stroke();
        }
    },
    /**
     * 
     * @param {integer} col
     */
    drawColumn: function(col) {
        DistGrid.ctx.lineWidth = 1;
        DistGrid.ctx.beginPath();
        DistGrid.ctx.moveTo(col, 0);
        DistGrid.ctx.lineTo(col, DistGrid.canvas.height - 1);
        DistGrid.ctx.strokeStyle = DistGrid.styles.line_color;
        DistGrid.ctx.stroke();
    },
    /**
     * Draws a circular dot on x,y coordenates
     * 
     * @param {integer} x
     * @param {integer} y
     */
    drawDot: function(x, y) {
//        DistGrid.ctx.fillStyle = DistGrid.styles.dot_color;
        DistGrid.ctx.strokeStyle = DistGrid.styles.point.color;
        DistGrid.ctx.beginPath();
//        DistGrid.ctx.arc(x, y, 3, 0, 2 * Math.PI, true);
        DistGrid.ctx.moveTo(parseFloat(x) - parseFloat(DistGrid.styles.point.radius), parseFloat(y) - parseFloat(DistGrid.styles.point.radius));
        DistGrid.ctx.lineTo(parseFloat(x) + parseFloat(DistGrid.styles.point.radius), parseFloat(y) + parseFloat(DistGrid.styles.point.radius));

        DistGrid.ctx.moveTo(parseFloat(x) + parseFloat(DistGrid.styles.point.radius), parseFloat(y) - parseFloat(DistGrid.styles.point.radius));
        DistGrid.ctx.lineTo(parseFloat(x) - parseFloat(DistGrid.styles.point.radius), parseFloat(y) + parseFloat(DistGrid.styles.point.radius));
        DistGrid.ctx.stroke();
//        DistGrid.ctx.fill();
    },
    /**
     * Draws a line between received and stored coordenates 
     * 
     * @param {array} couple
     * @param {array} coordenates
     */
    drawLine: function(couple, coordenates) {
        DistGrid.ctx.lineWidth = 1;
        DistGrid.ctx.beginPath();
        DistGrid.ctx.moveTo(couple[0], couple[1]);
        DistGrid.ctx.lineTo(coordenates[0], coordenates[1]);
        DistGrid.ctx.strokeStyle = DistGrid.styles.line_color;
        DistGrid.ctx.stroke();
    },
    /**
     * If actual mouse position is inside circle
     * 
     * @param {integer} x0
     * @param {decimal} y0
     * @param {integer} x1
     * @param {integer} y1
     * @returns {Boolean}
     */
    inCircle: function(x0, y0, x1, y1) {
        return Math.sqrt((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0)) < DistGrid.styles.circle_radius;
    },
    /**
     * Captures click event
     */
    mouseClickEventHandler: function() {
        if (DistGrid.step === 0) {//Vertical lines 
            var newArray = DistGrid.columns;
            DistGrid.columns = newArray.concat(DistGrid.coo[0]);
            MongoDBGelImage.mongoSetColumns();
            DistGrid.drawColumn(DistGrid.coo[0]);
        } else if (DistGrid.step === 1) {//New bezier

        } else if (DistGrid.step === 2) {//Place bezier

        } else if (DistGrid.step === 3) {//Set dots
            if (DistGrid.inCircle(DistGrid.circle[0], DistGrid.circle[1], DistGrid.coo[0], DistGrid.coo[1])) {
                var newArray = [[DistGrid.circle[0], DistGrid.circle[1]]];
                DistGrid.dots = newArray.concat(DistGrid.dots);
                MongoDBGelImage.mongoSetDots();
                DistGrid.drawDot(DistGrid.circle[0], DistGrid.circle[1]);
            }
        } else if (DistGrid.step === 4) {//Split in
            
        } else if (DistGrid.step === 5) {//Set matrix

        }
    },
    /**
     * Mouse position
     * 
     * @param {type} event
     * @returns {object}
     */
    MousePos: function(event) {
        event = (event ? event : window.event);
        return {
            x: event.pageX - DistGrid.canvas.offsetLeft,
            y: event.pageY - DistGrid.canvas.offsetTop
        };
    },
    /**
     * When creating a new bezier curve
     */
    newBezier: function() {
        DistGrid.step = 1;
        MongoDBGelImage.mongoSetStep();
        DistGrid.canvas.onmousedown = DistGrid.DragStart;
        DistGrid.canvas.onmousemove = DistGrid.Dragging;
        DistGrid.canvas.onmouseup = DistGrid.canvas.onmouseout = DistGrid.DragEnd;
        DistGrid.DrawCanvas();
    },
    /**
     * Places actual bezier curve to be drawed
     */
    placeBezier: function() {
        DistGrid.step = 2;
        MongoDBGelImage.mongoSetStep();
        DistGrid.canvas.onmousemove = null;
        var newArray = [
            [
                DistGrid.point.p1.x,
                DistGrid.point.p1.y,
                DistGrid.point.cp1.x,
                DistGrid.point.cp1.y,
                DistGrid.point.cp2.x,
                DistGrid.point.cp2.y,
                DistGrid.point.p2.x,
                DistGrid.point.p2.y
            ]
        ];
        DistGrid.beziers = newArray.concat(DistGrid.beziers);
        MongoDBGelImage.mongoSetBeziers();
        DistGrid.drawBezier(
            DistGrid.point.p1.x,
            DistGrid.point.p1.y,
            DistGrid.point.cp1.x,
            DistGrid.point.cp1.y,
            DistGrid.point.cp2.x,
            DistGrid.point.cp2.y,
            DistGrid.point.p2.x,
            DistGrid.point.p2.y
        );
    },
    /**
     * 
     * @returns {undefined}
     */
    placeAlleles: function(){
        var diff = 0;
        DistGrid.allelesRecorded.sort(function(a, b) {
            return b - a;
        });
        var top = DistGrid.allelesRecorded[0];
        var bottom = DistGrid.allelesRecorded[DistGrid.allelesRecorded.length - 1];
        var cant = parseFloat(bottom) - parseFloat(top);
        
        DistGrid.beziers.sort(function(a, b) {
            return a - b;
        });
        var resultt = DistGrid.solveBezier(
            DistGrid.beziers[0][0],
            DistGrid.beziers[0][1],
            DistGrid.beziers[0][2],
            DistGrid.beziers[0][3],
            DistGrid.beziers[0][4],
            DistGrid.beziers[0][5],
            DistGrid.beziers[0][6],
            DistGrid.beziers[0][7],
            DistGrid.columns[0]
        );
        var resultb = DistGrid.solveBezier(
            DistGrid.beziers[1][0],
            DistGrid.beziers[1][1],
            DistGrid.beziers[1][2],
            DistGrid.beziers[1][3],
            DistGrid.beziers[1][4],
            DistGrid.beziers[1][5],
            DistGrid.beziers[1][6],
            DistGrid.beziers[1][7],
            DistGrid.columns[0]
        );
        var inc = (parseFloat(resultb) - parseFloat(resultt)) / (parseFloat(cant));
        
        for (var i in DistGrid.allelesRecorded) {
            if (i != 0 && i != DistGrid.allelesRecorded.length - 1) {
                diff = parseFloat(DistGrid.allelesRecorded[i]) - parseFloat(DistGrid.allelesRecorded[i - 1]) + parseFloat(diff);
                var y0 = parseFloat(DistGrid.beziers[0][1]) + parseFloat(diff) * inc;
                var y1 = parseFloat(DistGrid.beziers[0][3]) + parseFloat(diff) * inc;
                var y2 = parseFloat(DistGrid.beziers[0][5]) + parseFloat(diff) * inc;
                var y3 = parseFloat(DistGrid.beziers[0][7]) + parseFloat(diff) * inc;
                
                var newArray = [
                    DistGrid.beziers[0][0],
                    y0,
                    DistGrid.beziers[0][2],
                    y1,
                    DistGrid.beziers[0][4],
                    y2,
                    DistGrid.beziers[0][6],
                    y3
                ];
                DistGrid.beziers.push(newArray);
                MongoDBGelImage.mongoSetBeziers();
                DistGrid.drawBezier(
                    DistGrid.beziers[0][0],
                    y0,
                    DistGrid.beziers[0][2],
                    y1,
                    DistGrid.beziers[0][4],
                    y2,
                    DistGrid.beziers[0][6],
                    y3
                );
            }
        }
    },
    /**
     * Redraws everything
     */
    redrawAll: function() {
        DistGrid.ctx.clearRect(0, 0, DistGrid.canvas.width, DistGrid.canvas.height);
        var temp1 = DistGrid.styles.line_color;
        var temp2 = DistGrid.styles.curve.color;
        
        if (DistGrid.step === 3) {
            DistGrid.styles.line_color = "rgba(0,0,0,0)";
        }
        for (var i in DistGrid.columns) {
            DistGrid.drawColumn(DistGrid.columns[i]);
        }
        
        if (DistGrid.step === 3) {
            DistGrid.styles.curve.color = "rgba(0,0,0,0)";
        }
        for (var i in DistGrid.beziers) {
            DistGrid.drawBezier(
                DistGrid.beziers[i][0],
                DistGrid.beziers[i][1],
                DistGrid.beziers[i][2],
                DistGrid.beziers[i][3],
                DistGrid.beziers[i][4],
                DistGrid.beziers[i][5],
                DistGrid.beziers[i][6],
                DistGrid.beziers[i][7]
            );
        }
        DistGrid.styles.line_color = temp1;
        DistGrid.styles.curve.color = temp2;
        for (var i in DistGrid.dots) {
            DistGrid.drawDot(DistGrid.dots[i][0], DistGrid.dots[i][1]);
        }
    },
    /**
     * Selecting dots
     */
    setDots: function() {
        DistGrid.step = 3;
        MongoDBGelImage.mongoSetStep();
        DistGrid.columns.sort(function(a, b) {
            return b - a;
        });
        DistGrid.beziers.sort(function(a, b) {
            return b[1] - a[1];
        });
        var newArray = [];
        var newCol = [];
        var newRow = [];
        DistGrid.basematrix = [];

        for (var bezier in DistGrid.beziers) {
            for (var col in DistGrid.columns) {
                var result = DistGrid.solveBezier(
                    DistGrid.beziers[bezier][0],
                    DistGrid.beziers[bezier][1],
                    DistGrid.beziers[bezier][2],
                    DistGrid.beziers[bezier][3],
                    DistGrid.beziers[bezier][4],
                    DistGrid.beziers[bezier][5],
                    DistGrid.beziers[bezier][6],
                    DistGrid.beziers[bezier][7],
                    DistGrid.columns[col]
                );
                newArray = [[DistGrid.columns[col], result]];
                newCol = newArray.concat(newCol);
                newArray = [];
            }
            newArray = [newCol];
            newRow = newArray.concat(newRow);
            newArray = [];
            newCol = [];
        }
        DistGrid.basematrix = newRow.concat(DistGrid.basematrix);
        DistGrid.columns.sort(function(a, b) {
            return a - b;
        });
        DistGrid.canvas.onmousemove = function(evt) {
            $('#position').html('pos:' + DistGrid.coo[0] + ', ' + DistGrid.coo[1]);
            function between(x, col) {
                return x >= col - (DistGrid.styles.circle_radius / 2) && x <= col + (DistGrid.styles.circle_radius / 2);
            }
            
            for (var col in DistGrid.columns) {
                if (between(DistGrid.coo[0], DistGrid.columns[col])) {
                    for (var bezier in DistGrid.beziers) {
                        if (between(DistGrid.coo[1], DistGrid.basematrix[bezier][col][1])) {
                            DistGrid.redrawAll();
                            DistGrid.circle = [];
                            if (DistGrid.inCircle(DistGrid.basematrix[bezier][col][0], DistGrid.basematrix[bezier][col][1], DistGrid.coo[0], DistGrid.coo[1])) {
                                DistGrid.circle = [DistGrid.basematrix[bezier][col][0], DistGrid.basematrix[bezier][col][1]];
                                DistGrid.ctx.beginPath();
                                DistGrid.ctx.fillStyle = DistGrid.styles.circle_color;
                                DistGrid.ctx.arc(DistGrid.basematrix[bezier][col][0], DistGrid.basematrix[bezier][col][1], DistGrid.styles.circle_radius, 0, Math.PI*2, false);
                                DistGrid.ctx.fill();
                                DistGrid.ctx.closePath();
                            }
                        }    
                    }
                }
            }
        };
    },
    /**
     * Checks if dot then 1 else 0
     */
    setMatrix: function() {
        DistGrid.step = 5;
        MongoDBGelImage.mongoSetStep();
        DistGrid.canvas.onmousemove = null;
        var newCol = [];
        var newRow = [];
        var one = 0;
        for (var row in DistGrid.basematrix) {//2 times
            for (var col in DistGrid.basematrix[row]) {//3 times
                var hash = {};
                for(var i = 0 ; i < DistGrid.dots.length; i += 1) {
                    hash[DistGrid.dots[i]] = i;
                }
                if (hash.hasOwnProperty(DistGrid.basematrix[row][col])) {
                    one = 1;
                }
                newCol.push(one);
                one = 0;
            }
            newRow.push(newCol);
            newCol = [];
        }
        DistGrid.matrix = newRow;
        MongoDBGelImage.mongoSetMatrix();
        $("#massive").html("");
        updateMatrix();
    },
    /**
     * Sets vertical lines
     */
    setVerticalLines: function() {
        DistGrid.step = 0;
        MongoDBGelImage.mongoSetStep();
        DistGrid.canvas.onmousemove = null;
    },
    /**
     * Solves bezier cubic curve for point (xp, 0)
     * 
     * @param {integer} x0
     * @param {integer} y0
     * @param {integer} x1
     * @param {integer} y1
     * @param {integer} x2
     * @param {integer} y2
     * @param {integer} x3
     * @param {integer} y3
     * @param {integer} xp
     * @returns {decimal}
     */
    solveBezier: function(x0, y0, x1, y1, x2, y2, x3, y3, xp) {
        var dx = x0;
        var cx = 3 * (x1 - x0);
        var bx = ((3 * (x2 - x1)) - cx);
        var ax = x3 - x0 - cx - bx;
        
        var upper = 1;
        var lower = 0;
        var tn = 0;
        
        function ftn(ts) {
            return ax * (ts * ts * ts) + bx * (ts * ts) + cx * ts + dx - xp;
        }
        
        for (var i = 1; i < 18; i++) {
            tn = (upper + lower) / 2;
            
            if (ftn(tn) > 0) {
                upper = tn;
            } else {
                lower = tn;
            }
        }

        var dy = y0;
        var cy = 3 * (y1 - y0);
        var by = ((3 * (y2 - y1)) - cy);
        var ay = y3 - y0 - cy - by;
        
        return ay * (tn * tn * tn) + by * (tn * tn) + cy * tn + dy;
    },
    /**
     * Sets vertical lines
     * 
     * @returns {undefined}
     */
    splitIn: function() {
        DistGrid.step = 4;
        MongoDBGelImage.mongoSetStep();
        var splitin = parseFloat(DistGrid.split) + parseFloat(1);//9
        var stored = '';
        DistGrid.columns.sort(function(a, b) {
            return b - a;
        });
        var distcols = DistGrid.columns;//inverted
        for (var i = 0; i < distcols.length; i++) {
            if (stored === ''){
                stored = distcols[i];
            } else {
                var increment = (parseFloat(distcols[i]) - parseFloat(stored)) / parseFloat(splitin);
                for (var j = 1; j < splitin; j++) {
                    var column = parseFloat(stored) + parseFloat(parseFloat(increment) * parseFloat(j));
                    DistGrid.drawColumn(column);
                    var newArray = DistGrid.columns;
                    DistGrid.columns = newArray.concat(column);
                }
                stored = distcols[i];
            }
        }
        DistGrid.columns.sort(function(a, b) {
            return a - b;
        });
        MongoDBGelImage.mongoSetColumns();
    },
    /**
     * Undo last action
     */
    undo: function(){
        if (DistGrid.step === 0) {
            DistGrid.columns.pop();
//            DistGrid.columns.sort(function(a, b) {
//                return b - a;
//            });
            MongoDBGelImage.mongoSetColumns();
        } else if (DistGrid.step === 1 || DistGrid.step === 2) {
            DistGrid.beziers.shift();
            MongoDBGelImage.mongoSetBeziers();
        } else if (DistGrid.step === 3) {
            DistGrid.dots.shift();
            MongoDBGelImage.mongoSetDots();
        }
        DistGrid.redrawAll();
    }
};